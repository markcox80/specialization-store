{in-package "SPECIALIZATION-STORE"}

This document defines a new type of function, called a store function,
whose behavior is a selected according to the /types/ of objects given
as arguments to the store function.

The major differences between a store function and common lisp's
generic function are:
{begin-list}
{item}
Types rather than classes are used to select behavior.
{item}
Optional, rest and/or keyword arguments are considered when
determining behavior.
{item}
Initialization forms for optional and keyword arguments are part of
the store function's state.
{item}
Support for compile time optimizations.
{item}
No support for method/specialization combination.
{end-list}

The design of the store function consists of the following layers:
{begin-list}
{item/label-ref :section section/object-layer}
{item/label-ref :section section/syntax-layer}
{item/label-ref :section section/glue-layer}
{item/label-ref :section section/lambda-lists}
{item/label-ref :section section/standard-classes}
{end-list}

The {ref :section section/object-layer :text "object layer"}
encapsulates the objects and operators used by a store function.

The {ref :section section/syntax-layer :text "syntax layer"} provides
a convenient syntax for defining new store functions and
specializations in the global environment.

The {ref :section section/glue-layer :text "glue layer"} connects the
syntax and object layers and is responsible for modifying the global
environment.

The {ref :section section/lambda-lists :text "lambda lists"} section
outlines how arguments to a store function are processed and how to
specify the domain of a specialization.

The requirements of the standard store function are described in the
{ref :section section/standard-classes} section.

Lastly, all of the symbols specified in this document have uppercase
symbol names and exported from a single package. The name of this
package is implementation specific.

{section section/object-layer "Object Layer"}
The object layer encapsulates the objects and operators used to
model store functions.

The object layer contains the following sublayers:
{begin-list}
{item/label-ref :section section/object-layer/store}
{item/label-ref :section section/object-layer/specialization}
{end-list}

All of the definitions associated with the object layer can be found
in the {ref :section section/object-layer/dictionary :text "object
layer dictionary"}.


{subsection section/object-layer/store "Store Object"}
A store object encapsulates all of the data needed by a store
function.

A store object manages a set of {ref :section
section/object-layer/specialization :text "specialization
objects"}. Each specialization object, or specialization, encapsulates
behaviour which a store function may invoke during an invocation.

The arguments accepted by a store function are represented using a
{ref :glossary store-lambda-list}.

Invocations of a store function are represented by the following
operators on {ref :glossary store-object :text "store objects"}:
{begin-list}
{item}{dictionary :ss :function funcall-store}
{item}{dictionary :ss :function apply-store}
{item}{dictionary :ss :function expand-store}
{end-list}

The functions {dictionary :ss :function funcall-store} and {dictionary
:ss :function apply-store} encapsulate run-time applications of a
store function.

The function {dictionary :ss :function expand-store} provides
opportunities to perform compile time optimizations.

Which specialization (or specializations) the above functions select
during an invocation is defined by the implementation of the store
object.

A store object is an instance of {dictionary :mop :type
funcallable-standard-object}. The function {dictionary :mop :function
set-funcallable-instance-function :text "assigned"} to the instance
performs the same operation as {dictionary :ss :function
funcall-store}.

Adding specializations to a store object is performed using the
function {dictionary :ss :function add-specialization}.

Removing specializations from the store object is performed using the
function {dictionary :ss :function remove-specialization}.

The set of specialization objects managed by a store object can be
obtained using the function {dictionary :ss :function
store-specializations}.

{subsection section/object-layer/specialization "Specialization Object"}
The specialization object, or specialization, encapsulates the
behaviour of a store function for arguments satisfying particular
types.

The types of input arguments for which the specialization is valid is
specified using a {ref :section
section/lambda-lists/specialized-lambda-list :text "specialized lambda
list"}. This lambda list can be retrieved from a specialization using
the function {dictionary :ss :function specialization-lambda-list}.

The type specifier denoting the type of values returned by the
specialization can be retrieved using the function {dictionary :ss
:function specialization-value-type}.

The run-time behaviour of the specialization is captured by the
function returned by {dictionary :ss :function
specialization-function}.

Any compile time optimizations available for a specialization are
performed using the function returned by {dictionary :ss :function
specialization-expand-function}.

A specialization object is an instance of {dictionary :mop :type
funcallable-standard-object}. The function {dictionary :mop :function
set-funcallable-instance-function :text "assigned"} to the instance
applies its arguments to the function returned by {dictionary :ss
:function specialization-function}.

{subsection section/object-layer/dictionary "Object Layer Dictionary"}
{heading "Conditions"}
{dictionary-section :type store-error}
{dictionary-section :function store-error-store}

{dictionary-section :type simple-store-error}
{dictionary-section :function simple-store-error-message}

{heading "Store Object Protocol"}
{dictionary-section :function funcall-store}
{dictionary-section :function apply-store}
{dictionary-section :function expand-store}

{dictionary-section :function add-specialization}
{dictionary-section :function remove-specialization}
{dictionary-section :function specialization-equal}
{dictionary-section :function store-specializations}
{dictionary-section :function (setf store-specializations)}
{dictionary-section :type duplicate-specialization-error}

{dictionary-section :function store-lambda-list}
{dictionary-section :function store-value-type}

{dictionary-section :function store-documentation}
{dictionary-section :function (setf store-documentation)}

{dictionary-section :type inapplicable-arguments-error}
{dictionary-section :function inapplicable-arguments}
{dictionary-section :type incongruent-specialization-error}

{heading "Specialization Protocol"}
{dictionary-section :function specialization-function}
{dictionary-section :function specialization-expand-function}

{dictionary-section :function specialization-lambda-list}
{dictionary-section :function specialization-value-type}

{dictionary-section :function specialization-documentation}
{dictionary-section :function (setf specialization-documentation)}

{section section/syntax-layer "Syntax Layer"}
This section outlines a convenient syntax for creating store functions
and adding specializations to them.

The syntax layer is not required to invoke the functions provided in
the glue layer. It is however, required to perform the same actions.

The {dictionary :ss :function defstore} macro is used to define new
store functions in the global environment.

The {dictionary :ss :function defspecialization} macro provides a
simple syntax for defining specializations.

The {dictionary :ss :function define-specialization} macro performs
the same task as {dictionary :ss :function defspecialization}, except
that it is possible to specify the run-time behavior and compile time
behavior separately.

The {ref :section section/syntax-layer/dictionary :text "syntax layer
dictionary"} contains all of the requirements for the syntax layer.

{subsection section/syntax-layer/dictionary "Dictionary"}
{dictionary-section :function defstore}
{dictionary-section :function defspecialization}
{dictionary-section :function define-specialization}
{dictionary-section :function defstore-using-class}
{dictionary-section :function define-specialization-using-object}
{dictionary-section :function defspecialization-using-object}

{section section/glue-layer "Glue Layer"}

The glue layer forms a bridge between the {ref :section
section/syntax-layer} and the {ref :section section/object-layer}. Its
purpose is to model the behavior of defining store functions in the
global environment.

The processes encapsulated by the glue layer are:
{begin-list}
{item}Defining a new store function.
{item}Redefining an existing store function.
{item}Defining a new specialization.
{item}Redefining an exist specialization.
{item}Capturing the lexical environment.
{end-list}

The ability to capture the lexical environment where the {dictionary
:ss :function defstore} macro is evaluated is required when optional
and keyword arguments are present in the store lambda list.

Unlike CLOS' generic functions, initialization of optional and keyword
arguments is defined by the store function. This choice was made as
dispatch can be performed in these scenarios by delegating to a helper
generic function or a store function containing all required
arguments. The following example shows the one-to-one mapping between
arguments in the function ~my-function~ to required arguments in the
delegate function ~%my-function~.

{begin-example}
(defgeneric %my-function (a b c d))

(defun my-function (a b &optional (c (default-c-value))
                        &key d)
  (%my-function a b c d))
{end-example}

Closing over the lexical environment of the {dictionary :ss :function
defstore} macro is achieved using completion functions. A completion
function is responsible for computing the default values of optional
and keyword arguments and communicating them to the next stage of the
store function dispatch procedure.

There are two types of completion functions, a function that computes
values at run-time and a function that computes types at compile time.

The run-time completion function is specified by the following lambda
expression which is processed in the lexical environment in which the
{dictionary :ss :function defstore} form was executed.

{begin-example}
(lambda (continuation)
  (lambda store-lambda-list
    (funcall continuation [[completed-arguments]]*)))
{end-example}

The compile-time completion function deduces the type of the value
returned by the initialization forms.

{begin-example}
(lambda (continuation)
  (lambda (form environment)
    (funcall continuation
             form environment completed-argument-types)))
{end-example}

Completion functions are only required when the store lambda list
contains either optional or keyword arguments.

The {ref :section section/glue-layer/dictionary :text "glue layer
dictionary"} contains all of the requirements for the glue layer.

{subsection section/glue-layer/dictionary "Dictionary"}
{heading "Store Namespace"}
{dictionary-section :type invalid-store-name-error}
{dictionary-section :function invalid-store-name}

{dictionary-section :function find-store}
{dictionary-section :function (setf find-store)}

{dictionary-section :function make-store-unbound}

{heading "Glue Layer Functions"}
{dictionary-section :function ensure-store}
{dictionary-section :function ensure-specialization}

{dictionary-section :type ensure-store-error}
{dictionary-section :function ensure-store-error-object}
{dictionary-section :type invalid-store-lambda-list-error}
{dictionary-section :function invalid-store-lambda-list}
{dictionary-section :type invalid-specialization-class-error}
{dictionary-section :function invalid-specialization-class}
{dictionary-section :type invalid-store-class-error}
{dictionary-section :function invalid-store-class}
{dictionary-section :type missing-completion-functions-error}

{heading "Glue Layer Protocol"}
Specialization object extensions.
{dictionary-section :function specialization-name}

Store object entensions.
{dictionary-section :function store-name}
{dictionary-section :function store-value-completion-function}
{dictionary-section :function store-type-completion-function}
{dictionary-section :function store-form-completion-function}
{dictionary-section :function store-specialization-class}

Glue layer delegates.
{dictionary-section :function ensure-store-using-object}
{dictionary-section :function ensure-specialization-using-object}

{section section/lambda-lists "Lambda Lists"}

{subsection section/lambda-lists/store-lambda-list "Store Lambda List"}

{subsection section/lambda-lists/specialized-lambda-list "Specialized Lambda List"}

{subsection section/lambda-lists/congruence "Congruence"}

{section section/standard-classes "Standard Classes"}

A specialization should be regarded as an efficient implementation of
behaviour for the specified argument types. In other words, if two or
more specializations belonging to a store function are applicable,
then these specializations should perform the same operation.

{section section/communicating-types "Communicating Type Information"}

{glossary-term store-function "store function"}
A function whose behaviour is determined by a {ref :glossary store-object}.

{glossary-term store-object "store object"}
Blah blah.

{glossary-term store-object-function "store object function"}
The run-time behavior of a store object.

{glossary-term store-object-expander "store object function"}
The compile-time behaviour of a store object.

{glossary-term specialization-object "specialization object"}
Blah.

{glossary-term store-lambda-list "store lambda list"}
Blah.

{define-citation amop :book
  :authors ("Gregor Kiczales" "Jim Des Rivieres")
  :title "The Art of the Metaobject Protocol"
  :year 1991
  :isbn "0262111586"
  :publisher "MIT Press"
  :address "Cambridge, MA, USA"}

||| Local Variables:
||| mode: flyspell
||| ispell-local-dictionary: "american"
||| End: