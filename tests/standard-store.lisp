(in-package "SPECIALIZATION-STORE.STANDARD-STORE.TESTS")
(in-suite standard-store-tests)

(defun default-completion-function ()
  (lambda (continuation)
    (lambda (&rest args)
      (apply continuation args))))

(test store-specialization-congruence
  (flet ((do-good (store-lambda-list specialization-lambda-list)
           (let* ((store (make-instance 'standard-store :lambda-list store-lambda-list :completion-function (default-completion-function)))
                  (specialization (make-instance 'standard-specialization :lambda-list specialization-lambda-list)))
             (finishes (add-specialization store specialization))))
         (do-bad (store-lambda-list specialization-lambda-list)
           (let* ((store (make-instance 'standard-store :lambda-list store-lambda-list :completion-function (default-completion-function)))
                  (specialization (make-instance 'standard-specialization :lambda-list specialization-lambda-list)))
             (signals store-error (add-specialization store specialization)))))
    (macrolet ((good (store-lambda-list specialization-lambda-list)
                 `(do-good ',store-lambda-list ',specialization-lambda-list))
               (bad (store-lambda-list specialization-lambda-list)
                 `(do-bad ',store-lambda-list ',specialization-lambda-list)))
      (good (a) (b))
      (bad (a) ())
      (bad (a) (b c))
      (bad (a) (a &optional b))
      (bad (a) (c &rest args))
      (bad (a) (d &key))

      (good (a &optional b) (c d))
      (bad (a &optional b) ())
      (bad (a &optional b) (c &optional d))
      (bad (a &optional b) (c d &optional e))

      (good (a &optional b &key hey) (c d &key hey))
      (bad (a &optional b &key hey) (a b &key))

      (good (a &rest args) (b &rest args))
      (bad (a &rest args) ())
      (good (a &rest args) (b c &rest args)))))

(test add-and-remove-specialization
  (let* ((store (make-instance 'standard-store :lambda-list '(a b) :completion-function (default-completion-function))))
    (flet ((add (specialized-lambda-list)
             (let ((s (make-instance 'standard-specialization :lambda-list specialized-lambda-list)))
               (add-specialization store s)
               s))
           (specialization-count (store)
             (length (store-specializations store))))
      (is (= 0 (specialization-count store)))
      (add '(a b))
      (is (= 1 (specialization-count store)))
      (add '(c d))
      (is (= 1 (specialization-count store)))
      (add '((c integer) d))
      (is (= 2 (specialization-count store)))
      (add '(c (d float)))
      (is (= 3 (specialization-count store)))
      (let ((s1 (add '((c integer) (d float)))))        
        (is (= 4 (specialization-count store)))
        (let ((s2 (add '((d integer) (c float)))))
          (is (= 4 (specialization-count store)))
          (is-true (find s2 (store-specializations store)))
          (is-false (find s1 (store-specializations store)))

          (remove-specialization store s2)
          (is (= 3 (specialization-count store)))
          (is-false (find s2 (store-specializations store))))))))

(test add-specialization/keywords
  (let* ((store (make-instance 'standard-store :lambda-list '(&key a) :completion-function (default-completion-function))))
    (flet ((add (specialized-lambda-list)
             (let ((s (make-instance 'standard-specialization :lambda-list specialized-lambda-list)))
               (add-specialization store s)
               s))
           (specialization-count (store)
             (length (store-specializations store))))
      (add '(&key a))
      (is (= 1 (specialization-count store)))
      (add '(&key (a t)))
      (is (= 1 (specialization-count store))))))

(test add-specialization/positional
  (let* ((store (make-instance 'standard-store :lambda-list '(a) :completion-function (default-completion-function))))
    (flet ((add (specialized-lambda-list)
             (let ((s (make-instance 'standard-specialization :lambda-list specialized-lambda-list)))
               (add-specialization store s)
               s))
           (specialization-count (store)
             (length (store-specializations store))))
      (add '(a))
      (is (= 1 (specialization-count store)))
      (add '((a t)))
      (is (= 1 (specialization-count store))))))

(test invoking-store
  (let* ((store (make-instance 'standard-store :lambda-list '(a) :completion-function (default-completion-function)))
         (specialization (make-instance 'standard-specialization
                                        :lambda-list '((a integer))
                                        :function #'(lambda (c)                                                      
                                                      (1+ c)))))
    (signals error (funcall-store store))
    (signals error (funcall-store store 1 2))
    (signals no-applicable-specialization-error (funcall-store store 1))
    (add-specialization store specialization)
    (= 2 (funcall-store store 1))
    (= 3 (apply-store store (list 2)))
    (signals no-applicable-specialization-error (funcall-store store 1d0))))
