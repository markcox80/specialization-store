(in-package "SPECIALIZATION-STORE.STANDARD-STORE.TESTS")
(in-suite standard-store-tests)

(defun default-completion-function ()
  (lambda (continuation)
    (lambda (&rest args)
      (apply continuation args))))

(test store-specialization-congruence
  (flet ((do-good (store-lambda-list specialization-lambda-list)
           (let* ((store (make-instance 'standard-store :lambda-list store-lambda-list :completion-function (default-completion-function)))
                  (specialization (make-instance 'standard-specialization :lambda-list specialization-lambda-list)))
             (finishes (add-specialization store specialization))))
         (do-bad (store-lambda-list specialization-lambda-list)
           (let* ((store (make-instance 'standard-store :lambda-list store-lambda-list :completion-function (default-completion-function)))
                  (specialization (make-instance 'standard-specialization :lambda-list specialization-lambda-list)))
             (signals store-error (add-specialization store specialization)))))
    (macrolet ((good (store-lambda-list specialization-lambda-list)
                 `(do-good ',store-lambda-list ',specialization-lambda-list))
               (bad (store-lambda-list specialization-lambda-list)
                 `(do-bad ',store-lambda-list ',specialization-lambda-list)))
      (good (a) (b))
      (bad (a) ())
      (bad (a) (b c))
      (bad (a) (a &optional b))
      (bad (a) (c &rest args))
      (bad (a) (d &key))

      (good (a &optional b) (c d))
      (bad (a &optional b) ())
      (bad (a &optional b) (c &optional d))
      (bad (a &optional b) (c d &optional e))

      (good (a &optional b &key hey) (c d &key hey))
      (bad (a &optional b &key hey) (a b &key))

      (good (a &rest args) (b &rest args))
      (bad (a &rest args) ())
      (good (a &rest args) (b c &rest args)))))

(test add-and-remove-specialization
  (let* ((store (make-instance 'standard-store :lambda-list '(a b) :completion-function (default-completion-function))))
    (flet ((add (specialized-lambda-list)
             (let ((s (make-instance 'standard-specialization :lambda-list specialized-lambda-list)))
               (add-specialization store s)
               s))
           (specialization-count (store)
             (length (store-specializations store))))
      (is (= 0 (specialization-count store)))
      (add '(a b))
      (is (= 1 (specialization-count store)))
      (add '(c d))
      (is (= 1 (specialization-count store)))
      (add '((c integer) d))
      (is (= 2 (specialization-count store)))
      (add '(c (d float)))
      (is (= 3 (specialization-count store)))
      (let ((s1 (add '((c integer) (d float)))))        
        (is (= 4 (specialization-count store)))
        (let ((s2 (add '((d integer) (c float)))))
          (is (= 4 (specialization-count store)))
          (is-true (find s2 (store-specializations store)))
          (is-false (find s1 (store-specializations store)))

          (remove-specialization store s2)
          (is (= 3 (specialization-count store)))
          (is-false (find s2 (store-specializations store))))))))

(test add-specialization/keywords
  (let* ((store (make-instance 'standard-store :lambda-list '(&key a) :completion-function (default-completion-function))))
    (flet ((add (specialized-lambda-list)
             (let ((s (make-instance 'standard-specialization :lambda-list specialized-lambda-list)))
               (add-specialization store s)
               s))
           (specialization-count (store)
             (length (store-specializations store))))
      (add '(&key a))
      (is (= 1 (specialization-count store)))
      (add '(&key (a t)))
      (is (= 1 (specialization-count store))))))

(test add-specialization/positional
  (let* ((store (make-instance 'standard-store :lambda-list '(a) :completion-function (default-completion-function))))
    (flet ((add (specialized-lambda-list)
             (let ((s (make-instance 'standard-specialization :lambda-list specialized-lambda-list)))
               (add-specialization store s)
               s))
           (specialization-count (store)
             (length (store-specializations store))))
      (add '(a))
      (is (= 1 (specialization-count store)))
      (add '((a t)))
      (is (= 1 (specialization-count store))))))

(test invoking-store
  (let* ((store (make-instance 'standard-store :lambda-list '(a) :completion-function (default-completion-function)))
         (specialization (make-instance 'standard-specialization
                                        :lambda-list '((a integer))
                                        :function #'(lambda (c)                                                      
                                                      (1+ c)))))
    (signals error (funcall-store store))
    (signals error (funcall-store store 1 2))
    (signals no-applicable-specialization-error (funcall-store store 1))
    (add-specialization store specialization)
    (= 2 (funcall-store store 1))
    (= 3 (apply-store store (list 2)))
    (signals no-applicable-specialization-error (funcall-store store 1d0))))

(test dispatch-function/basic
  (let* ((store (make-instance 'standard-store
                               :lambda-list '(a &optional b &key c)
                               :completion-function (lambda (continuation)
                                                      #+sbcl
                                                      (declare (sb-ext:muffle-conditions style-warning))
                                                      (lambda (a &optional (b 2) &key (c 3))
                                                        (funcall continuation a b :c c))))))
    (labels ((make (lambda-list function)
               (make-instance 'standard-specialization :lambda-list lambda-list :function function))
             (add (lambda-list function)
               (add-specialization store (make lambda-list function))))
      (add '((a integer) b &key c) (lambda (a b &key c)
                                     (declare (ignore a b c))
                                     1))
      (add '(a (b float) &key (c (integer 0))) (lambda (a b &key c)
                                                 (declare (ignore a b c))
                                                 2))
      (add '(a (b float) &key (c (integer * (0)))) (lambda (a b &key c)
                                                     (declare (ignore a b c))
                                                     3))
      (add '((a (integer 10)) b &key c) (lambda (a b &key c)
                                          (declare (ignore a b c))
                                          4))
      (is (= 1 (funcall-store store 1)))
      (is (= 1 (funcall-store store 1 "here")))
      (is (= 1 (funcall-store store 1 "here" :c "there")))
      (is (= 2 (funcall-store store "blah" 2.0)))
      (is (= 2 (funcall-store store "blah" 3.0 :c 4)))
      (is (= 3 (funcall-store store "blah" 5.0 :c -1)))
      (is (= 4 (funcall-store store 10)))
      (is (= 4 (funcall-store store 10 "here")))
      (is (= 4 (funcall-store store 10 "here" :c "there")))
      (signals no-applicable-specialization-error (funcall-store store "blah" 3.0 :c 4.0)))))

(test dispatch-function/rest
  (let* ((store (make-instance 'standard-store
                               :lambda-list '(a &rest args)
                               :completion-function (lambda (continuation)
                                                      #+sbcl
                                                      (declare (sb-ext:muffle-conditions style-warning))
                                                      (lambda (a &rest args)
                                                        (apply continuation a args))))))
    (labels ((make (lambda-list function)
               (make-instance 'standard-specialization :lambda-list lambda-list :function function))
             (add (lambda-list function)
               (add-specialization store (make lambda-list function))))
      (add '((a integer)) (lambda (a)
                            (declare (ignore a))
                            1))
      (add '(a (b float)) (lambda (a b)
                            (declare (ignore a b))
                            2))
      (add '(a (b float) (c (integer * (0)))) (lambda (a b c)
                                                (declare (ignore a b c))
                                                3))
      (add '((a (integer 10)) b c) (lambda (a b c)
                                     (declare (ignore a b c))
                                     4))
      (add '(a b c &rest args) (lambda (&rest args)
                                 (declare (ignore args))
                                 5))
      (is (= 1 (funcall-store store 1)))
      (is (= 1 (funcall-store store 10)))
      (is (= 2 (funcall-store store "blah" 2.0)))
      (is (= 3 (funcall-store store 1 2d0 -1)))
      (is (= 4 (funcall-store store 10 2d0 5)))
      (is (= 4 (funcall-store store 10 "here" "there")))
      (is (= 5 (funcall-store store 1 "here" :c "there")))
      (is (= 5 (funcall-store store "blah" 3.0 :c 4)))
      (is (= 5 (funcall-store store "blah" 5.0 :c -1)))
      (signals no-applicable-specialization-error (funcall-store store 1 "here"))
      (signals no-applicable-specialization-error (funcall-store store "blah")))))
